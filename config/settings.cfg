############################################################################################
# IMPORTANT: Users should NOT edit this file. Instead, copy the
#            lines you want to change into a new file named autoexec.cfg 
#            ( either here or in your var directory ).
#            This file will be overwritten when you upgrade, autoexec.cfg won't.
#            Be sure to save the file as plain text, not rich text, especially
#            if you're using TextEdit on a Mac.
############################################################################################

############################################################################################
#
# arena settings
#
############################################################################################

RESOURCE_REPOSITORY_SERVER	http://resource.armagetronad.net/resource/ # default resource repository, determined by the server
RESOURCE_REPOSITORY_CLIENT	http://resource.armagetronad.net/resource/ # fallback resource repository determined on the client (no use changing it on the server)

# defaults:
ARENA_AXES 4                                          # sets the number of possible driving directions (used only when map is axes-independent)
MAP_FILE    Anonymous/polygon/regular/square-1.0.1.aamap.xml   # sets the file path for the map, and if required, the URI to download the map from, in parenthesis

############################################################################################
# example sniplets
############################################################################################


#MAP_FILE   Your_mom/clever/repeat-0.3.2.aamap.xml    # square with obstacles

#MAP_FILE   Your_mom/clever/inaktek-0.7.2.aamap.xml   # octagon with obstacles
#ARENA_AXES 8                                         # set automatically by map to this value

#MAP_FILE   Luke-Jr/HexaTRON/HexaTRON-0.4.3.aamap.xml # hexagonal flower
#ARENA_AXES 6                                         # set automatically by map to this value

#MAP_FILE   Anonymous/polygon/regular/40-gon-0.1.1.aamap.xml   # almost circular
#MAP_FILE   Anonymous/polygon/regular/diamond-1.0.2.aamap.xml  # like the square, but corners cut off

#MAP_FILE   Z-Man/fortress/zonetest-0.1.0.aamap.xml            # test map for fortress zones
#MAP_FILE   Z-Man/fortress/for_old_clients-0.1.0.aamap.xml     # fortress map compatible with older clients

# for full compatibility of the for_old_clients map, you have to also follow the
# setting instructions in the comments inside the xml file.

############################################################################################
#
# networking settings
#
############################################################################################

# Artificially limiting compatibility of hosted games:
BACKWARD_COMPATIBILITY 1000 # Maximum number of network protocol versions backward compatibility ( will be clamped to maximal supported value; set to zero to not accept logins from older clients )
NEW_FEATURE_DELAY 0         # Disable features that only came in during the last X protocol versions.

# To the same effect, but uses absolute protocol versions (look up the help file versions.html)
# so if you want to set your limits at specific feature sets and not worry about updating
# your config when you install a game update, use these.
MIN_PROTOCOL_VERSION 0      # Minimum protocol version allowed to play.
MAX_PROTOCOL_VERSION 0      # If > 0, maximum protocol version allowed to play; features not supported by this version are going to be permanently disabled.

MAX_CLIENTS 16              # maximum number of clients that can connect to this machine
MAX_CLIENTS_SAME_IP_SOFT 4  # maximum number of clients from the same IP (soft limit, more users from the same IP will be kicked when the server is full and someone new connects)
MAX_CLIENTS_SAME_IP_HARD 8  # maximum number of clients from the same IP (hard limit, more logins will be ignored)

MAX_PLAYERS_SAME_IP      4  # maximum number of players from the same IP (note that each client can legally host up to four players)

# banning users

NETWORK_MIN_BAN          120 # when a banned client tries to connect, update the remaining ban-time to be at least this many seconds 

# autoban players for NETWORK_AUTOBAN_FACTOR * ( kph - NETWORK_AUTOBAN_OFFSET ) minutes
# when they get kicked; kph is the average number of kicks per hour that the player 
# got in the past. It's useful to read the full docs on these.
NETWORK_AUTOBAN_FACTOR   10  
NETWORK_AUTOBAN_OFFSET   5
NETWORK_AUTOBAN_MAX_KPH  30  # maximal value the kicks per hour can actually have (influences the measurement process )

# automatic kicking of spectators
NETWORK_SPECTATOR_TIME  0    # if > 0, this is the maximal time in seconds a client without players is tolerated

# protection against milking cheats (where friends pretend they are enemies 
# and kill each other for points)

ALLOW_ENEMIES_SAME_IP     0  # if set to 1, this allows two players that apparently come from the same machine to fight for points with each other
ALLOW_ENEMIES_SAME_CLIENT 0  # if set to 1, this allows two players that play on the same client to fight for points with each other

# If ALLOW_ENEMIES_SAME_IP is set to 0, you can allow players from the same IP to be enemies by whitelisting their authenticated names or IP:
# WHITELIST_ENEMIES_USERNAME player1@ player2@
# WHITELIST_ENEMIES_IP 127.0.0.1

ALLOW_CONTROL_DURING_CHAT 0  # if set to 1, this allows a player to issue cycle and camera control commands during chat (losing the chatbot and the yellow chat pyramid). This feature was buggy and has been disabled for 0.2.8.0.

ALLOW_IMPOSTERS 0            # allow two players to have the same name

# timebot/aimbot/grindbot detection. Those clientside enhancements can make various
# timing decisions better than humans. Tuning settings:

TIMEBOT_SENSITIVITY 1.0      # The sensitivity of the timebot detection code. 1.0 is the default and you 
                             # probably shouldn't deviate more than .5 from that.
			     # higher values increase the sensitivity and produce reactions faster.
TIMEBOT_KICK_SEVERITY .5     # If players get kicked by the timebot detection, it's done with this severity level.

# Actions to be taken when timebot usage is detected: on the setting 2, all those players who also spy on admin commands get the message.
TIMEBOT_ACTION_MEDIUM 1      # Action to take on a medium suspicion of timebottery. 0: do nothing, 1: log it, 2: message moderators, 3: message all players, 4: kick the offending player.
TIMEBOT_ACTION_HIGH 1        # Action to take on a high suspicion of timebottery. 0: do nothing, 1: log it, 2: message moderators, 3: message all players, 4: kick the offending player.
TIMEBOT_ACTION_MAX 1         # Action to take on a very high suspicion of timebottery. 0: do nothing, 1: log it, 2: message moderators, 3: message all players, 4: kick the offending player.



############################################################################################
#
# cycle physics
#
############################################################################################

CYCLE_TURN_MEMORY 3         # number of pending turn commands a cycle memorizes before opposing turns cancel each other

# speed; it's a good idea to read the full documentation for the acceleration settings.
CYCLE_SPEED 20.0            # basic cycle speed (m/s)
CYCLE_SPEED_MIN .25         # minimal cycle speed as ratio to CYCLE_SPEED
CYCLE_SPEED_DECAY_BELOW 5.0 # rate of cycle speed approaching the value of CYCLE_SPEED from below
CYCLE_SPEED_DECAY_ABOVE .1  # rate of cycle speed approaching the value of CYCLE_SPEED from above
CYCLE_START_SPEED 20.0      # speed at startup
CYCLE_ACCEL 15.0            # wall acceleration multiplicator
CYCLE_ACCEL_SELF 1.0        # multiplicator to CYCLE_ACCEL for your own wall
CYCLE_ACCEL_TEAM 1.0        # multiplicator to CYCLE_ACCEL for your temmates' walls
CYCLE_ACCEL_ENEMY 1.0       # multiplicator to CYCLE_ACCEL for your enemies' walls
CYCLE_ACCEL_RIM 0.0         # multiplicator to CYCLE_ACCEL for the rim walls
CYCLE_ACCEL_SLINGSHOT 1.0   # multiplicator to CYCLE_ACCEL if you're between your wall and another wall
CYCLE_ACCEL_TUNNEL 1.0      # multiplicator to CYCLE_ACCEL if you're between two walls that are not your own
CYCLE_ACCEL_OFFSET 2.0      # acceleration offset. Must be positive or smaller than -CYCLE_WALL_NEAR, otherwise there is a risk of a division by zero.
CYCLE_WALL_NEAR 6.0         # the distance from a wall below which wall-acceleration kicks in
CYCLE_SOUND_SPEED 20.0      # sound speed divisor 
CYCLE_BRAKE 30.0            # deceleration by braking (set to zero to disable brakes and to a negative value to turn brakes into a turbo)

# When you break from a wall, your speed is modified to SPEED * CYCLE_BOOST_? + CYCLE_BOOSTFACTOR_?,
# where ? is the type of wall you're breaking away from. The speed change isn't taken verbatim,
# but it's modified by the same formula the regular, continuous acceleration is modified with
# depending on the distance to the wall. The value given above is the maximal change, achieved if
# you're as close to the cycle as possible.

CYCLE_BOOST_SELF     0.0      # Speed boost when breaking from your own wall
CYCLE_BOOST_TEAM     0.0      # Speed boost when breaking from a teammate's wall
CYCLE_BOOST_ENEMY    0.0      # Speed boost when breaking from an enemy wall
CYCLE_BOOST_RIM      0.0      # Speed boost when breaking from the rim wall
CYCLE_BOOSTFACTOR_SELF   1.0  # Factor your speed is multiplied with when breaking from your own wall
CYCLE_BOOSTFACTOR_TEAM   1.0  # Factor your speed is multiplied with when breaking from a teammate's wall
CYCLE_BOOSTFACTOR_ENEMY  1.0  # Factor your speed is multiplied with when breaking from an enemy wall
CYCLE_BOOSTFACTOR_RIM    1.0  # Factor your speed is multiplied with when breaking from the rim wall

# turning
CYCLE_DELAY  .1             # minimum time between turns in seconds. Never enable the topology police if this is set lower than 0.001. Only values bigger than zero are supported.
CYCLE_DELAY_TIMEBASED 1.0   # turn delays will be based on the time since the last turn if this is set to 1 (default) and the distance if this is set to 0. Intermediate values and values out of these bounds are supported as well.
CYCLE_TURN_SPEED_FACTOR .95 # at every turn a cycle's speed is multiplied by this value

# rubber settings; it's a good idea to read the full documentation
CYCLE_RUBBER  1.0          # niceness when hitting a wall
CYCLE_PING_RUBBER 3.0      # niceness when hitting a wall: bonus for higher ping players
CYCLE_RUBBER_TIMEBASED 0.0 # rubber usage is based on distance travelled if this is set to 0 (default) and the time passed if this is set to 1. Intermediate values and values out of these bounds are supported as well.

CYCLE_RUBBER_SPEED 40.0                  # logarithmic speed of wall approximation when rubber is in effect ( every second, you get closer to the wall by a factor of ~0.4^{this value} )
CYCLE_RUBBER_MINDISTANCE .001            # The minimal distance rubber code keeps cycles from walls
CYCLE_RUBBER_MINDISTANCE_RATIO .0001     # Additional distance for every length unit of the wall you have in front of you
CYCLE_RUBBER_MINDISTANCE_RESERVOIR .005  # Additional distance if you have an empty rubber meter (gets faded out gradually as you use up all your rubber)
CYCLE_RUBBER_MINDISTANCE_UNPREPARED .005 # Additional distance for unprepared grinds; it gets applied when the cycle's last turn was just a fraction of a second ago and faded out preparation times larger than CYCLE_RUBBER_MINDISTANCE_PREPARATION.
CYCLE_RUBBER_MINDISTANCE_PREPARATION .2  # Timescale in seconds a cycle's last turn time is compared with to determine the effect of CYCLE_RUBBER_MINDISTANCE_UNPREPARED.

#CYCLE_WIDTH 0.0                         # the cycle's width. Attempts to enter tunnels that are narrower than this result in instant death. (not yet supported)
CYCLE_RUBBER_MINADJUST .05               # when adjusting to or 180ing into a wall, allow going closer by at least this amount ( relative to the last distance ). A value of zero may lead to cycles ending up on the wrong side of their own walls.

CYCLE_RUBBER_LEGACY 0                    # fallback to old, frame-dependant rubber code when old clients are present if this is 1
CYCLE_RUBBER_TIME 10.0                   # Timescale rubber is restored on

CYCLE_RUBBER_DELAY 0.0                   # during this fraction of the cycle delay time, rubber efficiency will be multiplied...
CYCLE_RUBBER_DELAY_BONUS .5              # by this factor ( meaning that rubber usage goes up by the inverse; a value of zero means rubber is completely disabled )

CYCLE_RUBBER_WALL_SHRINK 0               # With finite length trails, the used rubber is multiplied with this value and subtracted from the wall length. A value of 1 lets the trail recede at constant speed. All values are supported, but negative values may degrade performance and cause false positives from the topology police if that is enabled.

CYCLE_RUBBER_SYNC 1                      # Determines whether rubber is synced to clients. The default 1 makes it sync only to the owner of each cycle, a value of 0 does not sync it at all and renders rubber meters useless, a value of 2 syncs rubber of all cycles to all clients, which was the old behavior before this setting was introduced.
                                         # Note: this only has an effect if there are no side effects to cycle rubber values, specifically, CYCLE_RUBBER_WALL_SHRINK needs to be 0. If there are side effects, rubber is always synced.

# "open" vs "closed" play. To enforce "open" play, set the next value to something positive, 
# values between .5 and .9 make most sense. If you choose to do so, increase CYCLE_RUBBER_MINDISTANCE
# for optimal effect; with normal speed settings, keep it between .1 and 2.
CYCLE_RUBBER_MINDISTANCE_GAP 0           # If > 0, CYCLE_RUBBER_MINDISTANCE effectively is never taken to be bigger than this value times the size of any detected gaps the cycle can squeeze through.
CYCLE_RUBBER_MINDISTANCE_GAP_BACKDOOR  0 # As above, but this value is applied only to 'backdoor' gaps, gaps that lead you away from an enemy. If = 0, CYCLE_RUBBER_MINDISTANCE_GAP applies to backdoors, too. If you want to discourage backdooring, set this to something bigger than 1, 1.5 would be recommended.
CYCLE_RUBBER_MINDISTANCE_GAP_SIDE .5     # Gap detection only sees gaps that the cycle may reach in no less than this many seconds.

# braking
CYCLE_BRAKE_REFILL .1    # refill rate of brake reservoir
CYCLE_BRAKE_DEPLETE 1.0  # depletion rate of brake reservoir ( set to 0 to reenable pre 0.2.5 behaviour of infinite brakes )

# cycle width
CYCLE_WIDTH 0            # the width of a cycle in meters. If set, a cycle will take damage (=use up rubber or explode) if it drives through a tunnel narrower than this.
CYCLE_WIDTH_SIDE 0       # the minimal distance a cycle needs to have from every wall. If set, a cycle will take damage (=use up rubber or explode) if it drives closer.
CYCLE_WIDTH_RUBBER_MIN 1 # minimum rubber usage when a cycle is found in a situation illegal by the two above settings. The minimal value is applied if the space is almost enough.
CYCLE_WIDTH_RUBBER_MAX 1 # maximum rubber usage when a cycle is found in a situation illegal by the two above settings. This value is applied if there truly is no space left.

# If both _RUBBER_ settings are zero, cycles explode instantly when they get too close to walls.
# It is recommended that you leave CYCLE_WIDTH smaller than twice the value of
# CYCLE_RUBBER_MINDISTANCE, and CYCLE_WIDTH smaller than CYCLE_RUBBER_MINDISTANCE itself. 
# If you don't follow the first rule, cycles can be squished by other cycles coming from behind,
# if you don't follow the second rule, grinds that go too deep can become deadly even though
# there is still rubber left at the time of the turn.
# Clients from 0.2.8.3 on indicate a grind so close that nobody can enter it safely by 
# rendering the sparks only then. Clients older than that render sparks from a wall distance
# of 0.25 meters downwards; so a sensible set of values visually consistent with old
# clients would be this:
# CYCLE_WIDTH .25
# CYCLE_RUBBER_MINDISTANCE .3 to .4
# At normal values of CYCLE_RUBBER_SPEED, you should probably leave CYCLE_WIDTH_SIDE alone,
# unless you want to make squeezing through every kind of grind, no matter now sloppy it is,
# impossible.

# safe values for clients before 0.2.5.0:
#CYCLE_BRAKE_REFILL 0.0
#CYCLE_BRAKE_DEPLETE 0.0

# wall length settings
# if finite walls length is set and _SHRINK is nonzero, the length of the walls is 
# modified initially, as long as the driven distance is smaller than _SHRINK_OFFSET.
# The modified length is given by _LENGTH - _SHRINK * ( distance - _SHRINK_OFFSET ),
# where distance is the distance the cycle has traveled so far.
CYCLE_DIST_WALL_SHRINK        0.0  # Distance multiplier in wall length calculation. All values are legal.
CYCLE_DIST_WALL_SHRINK_OFFSET 0.0  # Distance offset in wall length calculation.

# respawn relevant settings (no server supports respawning yet, but the client is prepared)

CYCLE_INVULNERABLE_TIME 0.0        # Time in seconds a cycle is invulnerable after a respawn.
CYCLE_WALL_TIME 0.0                # Time in seconds a cycle does not make a wall after a respawn.
CYCLE_FIRST_SPAWN_PROTECTION 0     # Set to 1 if the invulnerability and wall delay should already be active on the initial spawn at the beginning of a round.

############################################################################################
# example sniplets
############################################################################################

# This will make turns behave like you learn in driving school: your turn
# radius goes up with the square of your speed
#CYCLE_DELAY_TIMEBASED 2

# This will make turns behave like crazy: faster cycles can make tighter turns:
#CYCLE_DELAY_TIMEBASED -1

# This is nasty: Basically, you'll only be allowed to turn below a certain
# speed. You have to brake before every turn!
#CYCLE_DELAY .01
#CYCLE_DELAY_TIMEBASED 10

# This setting will be a nasty surprise for exploiters of 180s and
# adjusting: it lowers the rubber protection for a short period of time
# after each turn (after all, driving directly beside a wall and turning
# toward it is a stupidity that demands punishment)
#CYCLE_RUBBER_DELAY .5

# These settings goes one step further and disables rubber directly after turns:
#CYCLE_RUBBER_DELAY .5
#CYCLE_RUBBER_DELAY_BONUS 0

# Traditionally, rubber usage is based on the distance your cycle would have
# travelled while you are stopped by rubber. This makes rubber less effective
# when going fast. We can change that so that only the time spent sitting in 
# front of a wall matters:
#CYCLE_RUBBER_TIMEBASED 1

# Or even make rubber more effective at high speeds:
#CYCLE_RUBBER_TIMEBASED 2

############################################################################################
#
# cycle networking settings
#
############################################################################################

LAG_O_METER_SCALE 1.0                   # Scaling of the lag-o-meter. 1 is the correct value. If you played previous versions, you may want to set it to
#LAG_O_METER_SCALE 0.5                  # which it was hardcoded to due to a bug.

CYCLE_SYNC_INTERVAL_ENEMY 1.0           # Time in seconds between server-client updates of enemy cycles
CYCLE_SYNC_INTERVAL_SELF  0.1           # Time in seconds between server-client updates of enemy cycles owned by the client itself
CYCLE_AVOID_OLDCLIENT_BAD_SYNC 0        # If set to 1, old clients will not get sync messages in situations that are known to confuse them
CYCLE_FAIR_ANTILAG 1                    # If set to 1, this deactivates the anti lag-sliding code when old clients are connected
CYCLE_TIME_TOLERANCE .1                 # Maximum time difference of execution of turns on server and client ( for clients that send timing information )
CYCLE_PACKETLOSS_TOLERANCE 0.0          # Cycle death is prevented as long as the player's failure to turn can be explained by the loss of this many network packets. Enabling this allows cheating with modified clients.

CYCLE_SYNC_FF 10.0                      # Speed of simulation of the extrapolating sync; decrease for lower CPU load, but higher effective ping
CYCLE_SYNC_FF_STEPS 1                   # Number of extrapolation simulation timesteps each real timestep; increase for better accuracy

CYCLE_SMOOTH_TIME .3                    # Timescale for smoothing options. Increasing this will make interpolation smoother, but less accurate. Decreasing it will make network synchronization jumpy.
CYCLE_SMOOTH_MIN_SPEED .2               # Minimum speed of smooth correction relative to cycle speed
CYCLE_SMOOTH_THRESHOLD .2               # Only syncs that differ from your position by less than this amount ( measured in speed ) will be smoothed slowly, bigger deviations will get faster handling.

CYCLE_MAX_REFCOUNT 30000                # Maximum allowed reference count on cycles before they self destruct.
                                        # This setting is to protect against performance related DOS attacks.
                                        # Older servers and clients would crash when 32768 references are reached,
                                        # performance problems start at around 10000 references.

TOPOLOGY_POLICE 0       # the topology police is your last defense against tunneling players. It tries to
                        # detect tunneling ( passing from one side of a wall to the other ) and kills the tunneler
                        # afterwards. It is disabled by default because there is a risk of false accusations, and because
                        # the regular game mechanisms are tunneling-proof in theory except for "fresh" walls.
TOPOLOGY_POLICE_PARALLEL 1 # if TOPOLOGY_POLICE is set to 1, this flag can be disabled to disable checks for parallel walls.
                           # Depending on the server's other settings, those can be false alarms in most cases.

############################################################################################
#
# chatbot settings
#
############################################################################################

CHATBOT_ALWAYS_ACTIVE 0            # if set to 1, the chatbot is active all of the time
CHATBOT_NEW_WALL_BLINDNESS .3      # the chatbot won't see walls that were built less than this many seconds ago
CHATBOT_MIN_TIMESTEP .3            # minimal time in seconds between chatbot thoughts
CHATBOT_DELAY .5                   # time between entering chat and chatbot activation
CHATBOT_RANGE 1.0                  # time in seconds the bot is capable of planning ahead
CHATBOT_DECAY .02                  # rate at which the quality of the chatbot decays over time

############################################################################################
#
# convenience settings
#
############################################################################################

HISTORY_SIZE_CONSOLE 10     # number of lines kept in the console history
HISTORY_SIZE_CHAT 10        # number of lines kept in the chat history

############################################################################################
#
# recording settings
#
############################################################################################

RECORDING_DEBUGLEVEL 0        # level of additional debug only information in recording file.
FAST_FORWARD_MAXSTEP 1.0      # Maximum recording time between rendered frames in fast forward mode
FAST_FORWARD_MAXSTEP_REAL .05 # Maximum real time between rendered frames in fast forward mode
FAST_FORWARD_MAXSTEP_REL .1   # Maximum fraction of the time left until the end of FF mode between rendered frames

############################################################################################
#
# visual settings
#
############################################################################################

include settings_visual.cfg

############################################################################################
#
# camera settings (more in settings_visual.cfg)
#
############################################################################################

CAMERA_FORBID_SMART 0           # forbid smart camera
CAMERA_FORBID_IN    0           # forbid internal camera
CAMERA_FORBID_FREE 0            # forbid free camera
CAMERA_FORBID_FOLLOW 0          # forbid fixed external camera
CAMERA_FORBID_CUSTOM 0          # forbid custom external camera
CAMERA_FORBID_SERVER_CUSTOM 1   # forbid server defined custom external camera

                                          # server defined custom camera position
CAMERA_SERVER_CUSTOM_BACK    30           # how much the camera is moved back
CAMERA_SERVER_CUSTOM_RISE    20           # the height of the camera above the cycle
CAMERA_SERVER_CUSTOM_BACK_FROMSPEED    0  # how much the camera is moved back for every m/s speed
CAMERA_SERVER_CUSTOM_RISE_FROMSPEED    0  # the height of the camera above the cycle for every m/s speed
CAMERA_SERVER_CUSTOM_PITCH   -.7          # inclination of the camera

# the following two settings are only in effect if the first is positive, otherwise, the values
# are taken from the clientside custom camera. Usually, you should leave them alone even if
# you modified the other CAMERA_SERVER_CUSTOM values.
CAMERA_SERVER_CUSTOM_TURN_SPEED     -1    # speed the custom camera turns with
CAMERA_SERVER_CUSTOM_TURN_SPEED_180 4     # factor to the turn speed after a quick reversal

############################################################################################
#
# game rules settings
#
############################################################################################

SCORE_WIN 10       # points you gain for being last one alive
SCORE_SUICIDE -4   # points you gain for every stupid death (race
                   # into the rim/your own wall)
SCORE_KILL 3       # points you gain for everyone racing into your wall
SCORE_DIE  -2      # points you gain for every time you race into
                   # someones wall

LIMIT_SCORE 100    # score limit (all limits for one match)
LIMIT_ROUNDS 10    # max number of rounds to play
LIMIT_TIME  30     # max time (in minutes)

EXPLOSION_RADIUS_SPEED_FACTOR 0 # Positive values will increase (SP_)EXPLOSION_RADIUS the faster the cycle is, negative value will decrease it. The exact formula is that the explosion radius gets increased by this value times the speed in m/s, so relatively low values (~0.01) are sensible.

DEADLY_EXPLOSIONS     0  # Should cycles in the blast radius of an explosion be destroyed?
SCORE_EXPLOSION_OWNER 0  # Points the owner of an explosion gains for destroying another enemy cycle.
SCORE_EXPLOSION       0  # Points the enemy cycle destroyed in an explosion gains.

# How wingmen are placed in formation. At SPEED_FACTOR 0, the unit 
# is meters, and the values are scaled up with speed.
# Don't ask where these default values come from, z-man thinks 
# they were chosen that oddly to avoid head-on collisions with 
# other teams starting from spawnpoints with sensible side offset. 

SPAWN_WINGMEN_BACK 2.202896 # determines how much each wingman is placed backwards
SPAWN_WINGMEN_SIDE 2.75362  # determines how much each wingman is placed sidewards

# These settings determine who gets the score for a kill. Generally, the player that
# has the most recent influence on the victim gets the credit (or the blame if it's a teammate).
# An influence currently is a close encounter with a wall, the time of the influence is
# the time the wall was built.
# The effective time entering the comparison is modified by these settings:

ENEMY_TEAMMATE_PENALTY 2500.0   # Penalty on the effective time in seconds if the influence is from a teammate
# ENEMY_SELF_PENALTY 3000.0     # Penalty on the effective time in seconds if the influence is from the victim itself (removed, does not make sense)
ENEMY_DEAD_PENALTY 0.0          # Penalty on the effective time in seconds if the influence comes from a dead player
ENEMY_CHATBOT_PENALTY 30.0      # Penalty in seconds if the victim is in chatbot state and the influence is just the chatbot evading a wall
ENEMY_CURRENTTIME_INFLUENCE 0.0 # If set to 1, not the build time of the encountered wall, but the current time enters the comparison. Arbitrary blending values are allowed.
ENEMY_SUICIDE_TIMEOUT 10000.0   # If no enemy influence can be found for the last this many seconds, the death counts as a suicide.

# for single player highscore hunt on this server:

SP_SCORE_WIN 10       # points you gain for being last one alive
SP_LIMIT_SCORE 100000 # score limit (all limits for one match)
SP_LIMIT_ROUNDS 10     # max number of rounds to play
SP_LIMIT_TIME   30    # max time (in minutes)

COLOR_STRINGS 1             # Generate strings that will be rendered with color effects.
FILTER_COLOR_STRINGS 0      # Filter color codes from all strings coming in over the network.
FILTER_COLOR_NAMES 0        # Filter color codes from player names.
FILTER_NAME_ENDS 1          # Filter whitespace from beginning and end of player names.
FILTER_NAME_MIDDLE 1        # Filter excess whitespace and other junk from the middle of player names.
FILTER_COLOR_SERVER_NAMES 0 # Filter color codes from server names in the server browser. Only affects the client.
VERIFY_COLOR_STRICT 1       # Verify color codes before interpreting them. Capital letters and anything not 0-9, a-f is not considered a color code then. If set to 0 (the in code default), out of range ascii characters are accepted and interpreted as 0.
VERIFY_COLOR_STRICT_OVERRIDE 1 # revert to lax verification if not all clients can do the strict verification. Annoying users like to use invalid codes.

SILENCE_DEFAULT 0  # silence new players by default?
ENABLE_CHAT 1      # allow public messages?

# ladder constants (outdated)

#LADDER_PERCENT_BET 10 # percentage of your score to be put in the pot
#LADDER_MIN_BET 1      # minimum credits to be put in the pot
#LADDER_TAX 1          # percentage the IRS takes from the pot

#LADDER_LOSE_PERCENT_ON_LOAD .2   # you lose this percentage of your
                                  # score every time
                                  # the server is restarted
#LADDER_LOSE_MIN_ON_LOAD .2       # but minimum this value
#LADDER_GAIN_EXTRA 1              # the winner gets his ping+ping charity
                                  # (in seconds) times this value extra
 
GAME_TIMEOUT 10.0       # base for game synchronization timeouts. 
                        # The value is approximately the maximal time between the end 
                        # of one round and the start of the next.

LAST_CHAT_BREAK_TIME -1.0      # Last round time a player in chat mode is able to pause the timer
EXTRA_ROUND_TIME 0.0           # Length of an extra pause at the beginning of the round
PLAYER_CHAT_WAIT_MAX 0.0       # Maximum time in seconds to wait for a single player to stop chatting.
PLAYER_CHAT_WAIT_FRACTION 0.0  # Maximum fraction of time to wait for a single player to stop chatting.
PLAYER_CHAT_WAIT_SINGLE 0      # Set to 1 if only one player should get his chat wait time reduced at any given time.
PLAYER_CHAT_WAIT_TEAMLEADER 1  # Set to 0 if all players, not just team leaders, should be allowed to pause the timer.

CHATTER_REMOVE_TIME 180  # Time in seconds after which a permanent chatter is removed from the game
IDLE_REMOVE_TIME 0       # Time in seconds after which an inactive player is removed from the game
IDLE_KICK_TIME 0         # Time in seconds after which an inactive player is kicked

KEEP_PLAYER_SLOT 0       # Set to 1 if spectators should be auto-removed if the server gets full so potential 
                         # players can always join. Warning, may also remove players if the server allows for
                         # the client slots to fill up before the player slots are all full.
                         # The system prefers to kick, in that order of priority:
                         #  Spectators over invited players over players
                         #  People with lower access level

# Both IDLE_KICK_TIME and KEEP_PLAYER_SLOT don't kick players/spectators with an access level
# of at least ACCESS_LEVEL_AUTOKICK_IMMUNITY.

DOUBLEBIND_TIME -10.0   # Time in seconds during which no two different keyboard events can 
                        # trigger the same action, negative or zero values disable the detection.

# win zone settings
WIN_ZONE_RANDOMNESS .8  # randomness factor of the initial position. Set it to 0 to fix the winzone in the center of the area, 1 to spread it all over the arena.
WIN_ZONE_EXPANSION   1  # expansion speed of the winzone in m/s
WIN_ZONE_INITIAL_SIZE 5 # radius in m the win zone starts with
WIN_ZONE_DEATHS 0       # set to 1 to turn the winzone into a deathzone

# 0.2.8 fortress settings (preliminary): a fortress zone has a "conquered" property; it
# starts at 0, if it reaches 1, the fortress is conquered. It gets modified according
# to the following rules every second:

FORTRESS_CONQUEST_RATE .5        # the number of enemies inside the fortress zone is counted, multiplied with this value and added to the "conquered" variable. Increase this to make conquering easier.
FORTRESS_DEFEND_RATE .25         # the number of owners inside the fortress zone is counted, multiplied with this value and subtracted from the "conquered" variable. Increase to make defending easier.
FORTRESS_CONQUEST_DECAY_RATE .1  # this value is subtracted. Increase to make defending easier.
FORTRESS_CONQUEST_TIMEOUT 0      # timeouts for enemy contacts with the zone. If a zone would collapse without a defender (as on Sumo), the zone will collapse harmlessly after all enemy contacts timed out.

# what happens when a zone gets conquered

FORTRESS_CONQUERED_SCORE 0        # the conquering party gets this many points (divided among the conquerors)
FORTRESS_HELD_SCORE 0             # points a team owning a zone gets at the end of the round if both team and zone survived
FORTRESS_CONQUERED_WIN 0          # if set to 1, the conquering party wins the round
FORTRESS_CONQUERED_KILL_MIN 0     # the closest X players of the owning team get killed at least
FORTRESS_CONQUERED_KILL_RATIO 0.0 # this fraction of the players of the owning team get killed

FORTRESS_SURVIVE_WIN 1            # if set to 1, the last team with an unconquered zone wins the round
FORTRESS_MAX_PER_TEAM 0           # if > 0, this is the maximal number of fortress zones ownable by a team. Closer zones are preferred. Use this to prune non-inhabited zones in multi-team maps.

SPAWN_POINT_GROUP_SIZE 0          # if > 2, this is interpreted as the number of spawn points in a spawn point group. AA then tries not to spawn one player alone in one spawn point group by redistributing them slightly.

FORTRESS_COLLAPSE_SPEED .5        # speed (units: 1/s) at which a collapsing fortress vanishes. The inverse of this value is the time between the conquest and the time the zone vanishes (and potentially kills its owners)

# base respawning

BASE_RESPAWN 0             # (0,1) if set to 1, any fortress / goal / flag base will respawn the team that owns it if a team player enters it
BASE_ENEMY_RESPAWN 0       # (0,1) if set to 1, any fortress / goal / flag base will respawn the team that owns it if an enemy player enters it

############################################################################################
#
# backward network compatibility
#
############################################################################################

#
# Armagetron Advanced is fully compatible with old clients down to 0.2.0 
# with the default settings. This changes if you alter some settings from 
# the default: the most glaring example would be changing the map to
# play on. The following settings determine what happens when an old
# client connects and some settings the client does not yet understand
# are not on their defaults. Set the configuration items to 2 to simply
# block the client, set it to 1 to allow the client in and revert the
# relevant settings to their default (this may be confusing to users
# of a newer client, they'll experience the change and have to adapt), 
# or 0 to just leave the settings as they are, but allow the client in 
# anyway. Choose 0 or 2 to be nice to new clients, 1 to be nice to old
# clients.
#

SETTING_LEGACY_BEHAVIOR_BREAKING     2  # For settings that absolutely break the client and make play impossible. Example of an affected setting: MAP_FILE
SETTING_LEGACY_BEHAVIOR_BUMPY        2  # For settings that allow play on old clients in principle, but with severe limitations (cycles bouncing around, player commands not executed on time). Example: CYCLE_DELAY_TIMEBASED
SETTING_LEGACY_BEHAVIOR_ANNOYING     0  # For settings that only cause minor annoyances on old clients, like enemy cycles stopping for .1 seconds after each turn. Example: CYCLE_RUBBER_MINDISTANCE
SETTING_LEGACY_BEHAVIOR_CHEATING     2  # For settings where the default behavior could be considered cheating if non-default was set. Example: DOUBLEBIND_TIME
SETTING_LEGACY_BEHAVIOR_VISUAL       0  # For settings that only affect status displays and visuals, not game physics. Example: CYCLE_RUBBER_* (the client displays the rubber meter, but it's not used for anything)

#
# Instead of selecting the behavior per group, you can override the 
# behavior of the affected configuration one by one: to change it
# for a variable named FOO, set FOO_OVERRIDE to 1 to revert FOO to
# its default when an old client connects, or 0 to let the old client
# in and leave FOO as it was. The default is always 3, which means
# to use the setting of the class corresponding to FOO. For map
# settings, this means concretely:
#

# uncomment the following line if you want to revert to the default map as soon as a client that
# does not yet support maps connects.
#MAP_FILE_OVERRIDE   1

# uncomment this line if you want to use a non-default map even if old clients are online
# (useful for example if your map only differs from the default map in the spawnpoints)
#MAP_FILE_OVERRIDE   0

# default override setting: let the setting class decide. In the case of maps, the class
# is BREAKS (old clients can't cope at all with non-default settings), so old clients
# are not allowed to connect if MAP_FILE differs from the default.
MAP_FILE_OVERRIDE    3

############################################################################################
#                       EXPERT SECTION
# The settings in this section sometimes have obscure effects and you
# sometimes need to know how the settings are used in the code to predict
# the effects of changes.
# They're unsupported, undocumented (apart from what you see in this file)
# and may change meaning from release to release.
############################################################################################


# server browser query settings. Affect clients and master servers.

BROWSER_QUERY_FILTER         1     # query filter. Set to 0 to poll all servers, 1 to query servers with nonnegative score bias, 2 to query only those with positive bias and 3 to not query at all. Non-queried servers will appear to have ping 999; the player info comes indirectly from the master server.
BROWSER_QUERIES_SIMULTANEOUS 20    # max. number of simultaneous query messages that are sent
BROWSER_QUERY_DELAY_SINGLE   0.5   # time delay between queries of the same server
BROWSER_QUERY_DELAY_GLOBAL   0.025 # time delay between all queries
BROWSER_NUM_QUERIES          3     # number of queries per try
BROWSER_CONTACTLOSS          4     # number of failed contact attempts before a server can be considered lost

# Priorities of bookmarks on the various sorting methods. 0 means bookmarks have
# no influence on the sorting, 1 means bookmarks are a secondary sorting key and
# therefore bookmarked servers float a bit to the top, and 2 makes bookmarks
# absolute priority and bookmarked servers are always top of the list.
BROWSER_BOOKMARK_PRIORITY_NAME 0   # priority of bookmarks for sorting by name
BROWSER_BOOKMARK_PRIORITY_PING 2   # priority of bookmarks for sorting by ping
BROWSER_BOOKMARK_PRIORITY_USERS 1  # priority of bookmarks for sorting by users
BROWSER_BOOKMARK_PRIORITY_SCORE 2  # priority of bookmarks for sorting by score

# delayed timer sync packets are culled from the stats with a force proportional to
# CULL_DELAY_MIN+max( CULL_DELAY_END-t , 0 )*CULL_DELAY_PER_SECOND
CULL_DELAY_END         3
CULL_DELAY_PER_SECOND  3
CULL_DELAY_MIN         3

# On some occasions, to avoid phasing bugs, we let a cycle drop its trail and
# build a new segment. This is invisible to the player, but the code is better
# at handling the dropped segments. This value determines in which intervals
# this can happen, as there is a performance price both in local CPU usage
# and network bandwidth consumption.
CYCLE_MIN_WALLDROP_INTERVAL .05

# Slicing and dicing time
# Sometimes, due to real world glitches, large timesteps need to be simulated.
# Simulating them all at once is a recipe for disaster, so we slice the
# big timestep into many small ones. Care needs to be taken, if the
# small steps are too small, a weak server may not be able to keep up with
# the action. When the two settings contradict each other in a given situation,
# TIMESTEP_MAX_COUNT takes precedence.

TIMESTEP_MAX .2       # the maximal size of the small timesteps
TIMESTEP_MAX_COUNT 10 # the maximal number of small timesteps to divide a large timestep in

# If the cycle simulation code on the server thinks that a client cycle control command is missing
# due to packet loss (and a later command has already arrived), it will wait for this long
# times the ping for the missed packet to arrive.
CYCLE_PACKETMISS_TOLERANCE 3

# Game level lag compensation

# The network code level only is capable of predicting and compensating stable latency times.
# It can't properly react on variances in the ping and the occasional packet loss burst.
# That's where the game level lag compensation kicks in. First, let's handle the server
# side:

# The server allocates each client a certain time amount of extra lag credit. If a
# command message arrives late and the credit is not used up, the simulation of the
# game object in question can be rolled back to the time of the command, and the
# amount of time that is rolled back is subtracted from the lag credit. This
# variable determines the total amount of lag credit maximally available,
# measured in seconds. Setting this to a finite value allows for some cheating by
# manipulated clients, so don't increase it too much. The default value does not
# allow cheaters to create too much damage.
LAG_CREDIT 0.5

# but not more than this much credit is given for a single event.
LAG_CREDIT_SINGLE 0.1

# and not more than this multiple of the measured lag variance of all clients.
# (Set to 0 to disable this clamping.)
LAG_CREDIT_VARIANCE 3.0

# Lag credit is not something that is available once. Just like rubber, lag credit
# is refilled over time. This variable tells you how long it takes before a completely
# used up lag credit takes to completely refill. 
LAG_CREDIT_TIME 600

# The server sends messages to the client, informing it about lag compensation that used
# up lag credit. The client tries to avoid using up too much credit by manipulating the game
# timer, more on that later. This is the server determined fill ratio of the lag credit
# that the client tries to maintain. You shouldn't need to touch this.
LAG_SWEET_SPOT .2

# Now, to the clientside settings. As mentioned, the client receives information from the
# server whenever a game object control message was measurably delayed and compensation
# was required. In order to avoid those events in the future, the client manipulates the
# game timer; it makes it go slightly faster for a while so game object control commands
# get sent with a later timestamp and don't have to be backdated before they can be executed
# accurately. Two counters keep track of the lag reports, one slow one for compensating
# long term fluctuations in the link quality, and a fast one for compensating lag spikes.

# This variable controls how much relative speedup the game timer maximally can get
# during compensation:
LAG_MAX_SPEEDUP_TIMER .2

# These two variables control how fast the lag measurers go back to reporting "Situation
# normalized, no measurable lag". The variables give the time for that in seconds.
LAG_SLOW_TIME 30.0
LAG_FAST_TIME 2.0

# These two variables determine the impact of lag reports from the server on the two
# measurers. The impact is full on the fast measurer and lower on the slow measurer,
# because the slow measurer takes longer to recover and shouldn't react in panic.
LAG_SLOW_WEIGHT 0.2
LAG_FAST_WEIGHT 1.0

# On top of the measured lag, the timer goes faster by this amount in seconds even
# if no lag was reported. Increase this if you know you have a very bad network link
# and if you are experiencing lag slides on servers running 0.2.8.3 or later.
# This setting only has an effect on the client.
LAG_OFFSET_CLIENT 0.0

# This setting has exactly the same effect, but is server controlled. Use it if your
# server is on a crappy connection.
LAG_OFFSET_SERVER 0.0

# In the very unlikely event that your system timer goes slow or fast and you absolutely
# cannot do anything about that, you can make ArmagetronAd multiply time measurements
# with the following value. For example, if your system timer is about 10% too fast, you 
# can use the value 0.909 to compensate. Deviations of less than 1% are usually compensated
# by the network code. NOTE: Do not change this while the program is running, this will cause
# huge hiccups or freezes.
TIME_FACTOR 1.0

# deprecated settings, they'll go away unless there are protests

CYCLE_RUBBER_MALUS_TURN 0                       # rubber usage gets increased by this amount after each turn...
CYCLE_RUBBER_MALUS_TIME 5                       # but the effect wears off after about this many seconds

############################################################################################
#
# Debugging (only available if compiled for debug)
#
############################################################################################

# packet loss simulation: these settings artificially lose packets.
# their value is the ratio of lost packets on receiving and sending; 1.0 loses every packet.
SIMULATE_RECEIVE_PACKET_LOSS 0.0
SIMULATE_SEND_PACKET_LOSS 0.0
