module AAConfig
  
  # Paths are relative the Rakefile
  SRC_DIR = File.expand_path(File.dirname(__FILE__) + "/..")
  
  BUILD_DIR = File.expand_path((ENV["SYMROOT"] || "#{SRC_DIR}/../armagetronad-build/build") + "/..")
  
  PRODUCT_NAME = ENV["PRODUCT_NAME"] || "Armagetron Advanced"
  
  PACKGAGE_RESOURCE_DIR = [
    ENV["CONFIGURATION_BUILD_DIR"] || "",
    PRODUCT_NAME + (ENV["WRAPPER_SUFFIX"] || ""),
    PRODUCT_NAME[/dedicated/i] ? "" : "Contents/Resources"
  ].join("/")
    
  
  BUILD_TYPE = File.exists?(SRC_DIR + "/.svn") ? :development : :release
  
  def self.process_file(orig, package_dir=nil)
    result_file = (BUILD_DIR + "/" + orig).sub(/\.in$/, '')
    orig = SRC_DIR + "/" + orig
    
    # Process the file (replace tags, copy to build dir)
    file result_file => [orig] do |t|
      mkdir_p(File.dirname(t.name))
      cp(t.prerequisites[0], t.name)
      
      # replace the tags
      open(t.name, "r+") do |f|
        data = f.read
        TAG_MAPPINGS.each { |tag, value| data.gsub!("@#{tag}@", value) }
        f.rewind
        f.print(data)
        f.truncate(f.pos)
      end      
    end
    task :process_files => result_file
    
    # Should the file be included with the game dist?
    if package_dir
      package_dest = PACKGAGE_RESOURCE_DIR + "/" + package_dir + "/" + File.basename(result_file)
      file package_dest => [result_file] do |t|
        mkdir_p(File.dirname(t.name))
        cp(t.prerequisites[0], t.name)
      end
      task :package_files => package_dest
    end
    
  end
    
  def self.version
    if BUILD_TYPE == :development
      %x("#{SRC_DIR}/batch/make/version" "#{SRC_DIR}").chomp
    else
      File.read("#{SRC_DIR}/src/macosx/version.h.in").scan(/#define VERSION "(.*)"/)[0][0]
    end
  end
  
  def self.swig_module(mod, dependencies)
    swig_file = "#{AAConfig::SRC_DIR}/src/swig/ext/armagetronad/#{mod}/#{mod}.i"
    result_file = swig_file.sub(AAConfig::SRC_DIR, AAConfig::BUILD_DIR).sub(/\.i$/, "_wrap.cxx")
    
    swig_file_dependencies = dependencies.map { |d| Dir.glob("#{SRC_DIR}/src/swig/ext/armagetronad/#{d}/*.i") }
    swig_file_dependencies.flatten!
    header_files = swig_file_dependencies.map { |f| f.pathmap("%-1d/%n.h") }
    
    # reject some header files
    dependencies.each do |depend|
      # get rid of tools.h, network.h, etc…
      header_files.reject! { |header| header.pathmap("%n") == depend }
      
      # get rid of typemaps headers
      header_files.reject! { |header| %w[tTypemaps.h nTypemaps.h rTypemaps.h
                                         uTypemaps.h eTypemaps.h gTypemaps.h].include?(header.pathmap("%f"))  }
    end
    
    header_files.map! { |f| "#{SRC_DIR}/src/#{f}" }
    depends = swig_file_dependencies + header_files

    # build the swig module cxx file
    file(result_file => [swig_file, *depends]) do |t|

      # the include directories to pass to swig
      include_directories = dependencies.map { |d|
        ["#{SRC_DIR}/src/#{d}", "#{SRC_DIR}/src/swig/ext/armagetronad/#{d}"]
      }.flatten
      include_directories.map! { |d| "\t-I#{d} " }

      mkdir_p(File.dirname(t.name))
      sh %{swig -c++ -ruby -autorename \\
        #{include_directories.join(" \\\n")} \\
        -I#{SRC_DIR}/src/macosx/client \\
        -I#{SRC_DIR}/src/macosx \\
        -o #{t.name} \\
        #{t.prerequisites[0]}}
    end
    
    # creates all the swig cxx files
    task "swig-module" => result_file
    
    result_extconf = BUILD_DIR + "/src/swig/ext/armagetronad/#{mod}/extconf.rb"
    # create the extconf file for this module
    file(result_extconf => ["#{SRC_DIR}/src/swig/ext/armagetronad/#{mod}/extconf.rb.in"]) do |t|
      mkdir_p(File.dirname(t.name))
      cp(t.prerequisites[0], t.name)
      open(t.name, "r+") do |f|
        data = f.read
        data.gsub!("@top_srcdir@", SRC_DIR)
        data.gsub!("@CPPFLAGS@", "-I/Library/Frameworks/ArmagetronAdvanced/current/SDL.framework/Headers -I#{SRC_DIR}/src/macosx/client -I#{SRC_DIR}/src/macosx")
        f.rewind
        f.print(data)
        f.truncate(f.pos)
      end    
    end
    
    task "extconf.rb" => result_extconf
    
    result_setup = "#{BUILD_DIR}/src/swig/setup.rb"
    file(result_setup => "#{SRC_DIR}/src/swig/setup.rb") do |t|
      cp(t.prerequisites[0], t.name)
    end
    
    task "setup.rb" => result_setup
    
    task "run" => ["swig-module", "extconf.rb", "setup.rb"] do
      sh %{(cd "#{BUILD_DIR}/src/swig" && ruby1.8 setup.rb)}
    end
  end
  
  
  TAG_MAPPINGS = {
    "version" => version(),
    "year" => Time.now.strftime("%Y"),
    "progtitle" => "Armagetron Advanced"
  }
  
end

# ========
# = SWIG =
# ========

namespace "swig" do
  AAConfig.swig_module("tools", %w[tools])
  AAConfig.swig_module("network", %w[tools network])
  AAConfig.swig_module("render", %w[tools network render])
  AAConfig.swig_module("ui", %w[tools network render ui])
  AAConfig.swig_module("engine", %w[tools network render ui engine])
  AAConfig.swig_module("tron", %w[tools network render ui engine tron])
  
  # Copy over the lib directory
  FileList.new("#{AAConfig::SRC_DIR}/src/swig/lib/**/*").each do |lib|
    result_lib = lib.sub(AAConfig::SRC_DIR, AAConfig::BUILD_DIR)
    if File.directory?(lib)
      directory(result_lib)
    else
      file result_lib => lib do
        cp(lib, result_lib)
      end
    end
    task "run" => result_lib
  end
end

# =========
# = Xcode =
# =========

namespace "xcode" do
  
  task :prepare => [:process_files, :sort_resources]
  task :cleanup => [:package_files, :package_resouces]
  
  task :sort_resources do
    if !File.exists?("#{AAConfig::BUILD_DIR}/resource")
      if AAConfig::BUILD_TYPE == :development
        sh %{"#{AAConfig::SRC_DIR}/batch/make/sortresources" \\
             "#{AAConfig::SRC_DIR}/resource/proto" \\
             "#{AAConfig::BUILD_DIR}/resource/included" \\
             "#{AAConfig::SRC_DIR}/batch/make/sortresources.py"}
      else
        cp_r("#{AAConfig::SRC_DIR}/resource", AAConfig::BUILD_DIR)
      end
    end
    
  end
  
  task :package_resouces do
    if !File.exists?("#{AAConfig::PACKGAGE_RESOURCE_DIR}/resource")
      cp_r("#{AAConfig::BUILD_DIR}/resource", AAConfig::PACKGAGE_RESOURCE_DIR)
    end
  end

  AAConfig.process_file("src/macosx/version.h.in")
  AAConfig.process_file("src/macosx/English.lproj/InfoPlist.strings.in", "English.lproj")
  AAConfig.process_file("config/aiplayers.cfg.in", "config")  
  AAConfig.process_file("language/languages.txt.in", "language")
  
end

# ==================
# = Beautification =
# ==================

desc "Uses project defaults and updates file timestamps"
task :rebeautify do
  #
  sh %{ARTISTIC_STYLE_OPTIONS="#{AAConfig::SRC_DIR}/config/astylerc" \\
       "#{AAConfig::SRC_DIR}/batch/make/beautify" -t "#{AAConfig::SRC_DIR}" "#{AAConfig::SRC_DIR}/.beautytag.re"}
end

desc "Switches between your settings (beautify-personal) to the project defaults and leaves timestamps untouched"
task :beautify do
  rm_f %{"#{AAConfig::SRC_DIR}/.beautytag.personal"}
  sh %{ARTISTIC_STYLE_OPTIONS="#{AAConfig::SRC_DIR}/config/astylerc" \\
       "#{AAConfig::SRC_DIR}/batch/make/beautify" "#{AAConfig::SRC_DIR}" "#{AAConfig::SRC_DIR}/.beautytag"}
end

desc "Uses your personal settings. Run “rake beautify” before commit!"
task :beautify_personal do
  rm_f %{"#{AAConfig::SRC_DIR}/.beautytag"}, %{"#{AAConfig::SRC_DIR}/.beautytag.re"}
  sh %{ARTISTIC_STYLE_OPTIONS=$HOME/.astylerc \\
       "#{AAConfig::SRC_DIR}/batch/make/beautify" "#{AAConfig::SRC_DIR}" "#{AAConfig::SRC_DIR}/.beautytag.personal"}
end

task :remove_version do
  rm_rf("#{AAConfig::BUILD_DIR}/src/macosx")
end

desc "Update version"
task :update_version => ["remove_version", "xcode:process_files"]
